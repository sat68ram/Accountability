Timelines / Porgram/Project Screen

Panel 1: 
WITH active AS (
  SELECT
    PROJECT_ID,
    START_DATE,
    COALESCE(END_DATE_ACTUAL, END_DATE_PLANNED) AS END_DATE_EFFECTIVE
  FROM PMO_DB.DIMENSIONS.DIM_PROJECT
  WHERE IS_ACTIVE = TRUE
),

-- Spend & budget "so far" (through current month)
fin_to_date AS (
  SELECT
    f.PROJECT_ID,
    SUM(f.BUDGET_MONTHLY_USD) AS budget_to_date_usd,
    SUM(f.ACTUAL_SPEND_USD)   AS actual_to_date_usd
  FROM PMO_DB.FACTS.FACT_FINANCIAL f
  JOIN active a
    ON a.PROJECT_ID = f.PROJECT_ID
  WHERE f.MONTH <= DATE_TRUNC('MONTH', CURRENT_DATE())
  GROUP BY f.PROJECT_ID
),

-- Latest progress snapshot per active project (for on-time %)
latest_progress AS (
  SELECT
    fp.PROJECT_ID,
    fp.SNAPSHOT_DATE,
    fp.STATUS,
    fp.SPI,
    fp.CPI
  FROM PMO_DB.FACTS.FACT_PROGRESS fp
  JOIN active a
    ON a.PROJECT_ID = fp.PROJECT_ID
  QUALIFY fp.SNAPSHOT_DATE = MAX(fp.SNAPSHOT_DATE) OVER (PARTITION BY fp.PROJECT_ID)
),

-- Risk exposure per active project (open risks only)
risk_open AS (
  SELECT
    r.PROJECT_ID,
    -- severity weight (tweak weights as you like)
    SUM(
      (r.PROBABILITY_PCT / 100.0) *
      CASE r.SEVERITY
        WHEN 'LOW'      THEN 1
        WHEN 'MEDIUM'   THEN 2
        WHEN 'HIGH'     THEN 3
        WHEN 'CRITICAL' THEN 5
        ELSE 1
      END
    ) AS risk_exposure_index
  FROM PMO_DB.FACTS.FACT_RISK r
  JOIN active a
    ON a.PROJECT_ID = r.PROJECT_ID
  WHERE r.STATUS = 'OPEN'
  GROUP BY r.PROJECT_ID
),

-- Roll up all project-level measures
project_kpis AS (
  SELECT
    a.PROJECT_ID,
    DATEDIFF('DAY', a.START_DATE, a.END_DATE_EFFECTIVE) AS duration_days,

    COALESCE(f.budget_to_date_usd, 0) AS budget_to_date_usd,
    COALESCE(f.actual_to_date_usd, 0) AS actual_to_date_usd,

    lp.STATUS AS latest_status,

    COALESCE(ro.risk_exposure_index, 0) AS risk_exposure_index
  FROM active a
  LEFT JOIN fin_to_date f
    ON f.PROJECT_ID = a.PROJECT_ID
  LEFT JOIN latest_progress lp
    ON lp.PROJECT_ID = a.PROJECT_ID
  LEFT JOIN risk_open ro
    ON ro.PROJECT_ID = a.PROJECT_ID
)

SELECT
  COUNT(*) AS total_active_projects,

  ROUND(AVG(duration_days), 1) AS avg_duration_days,

  ROUND(SUM(actual_to_date_usd), 2) AS total_spend_so_far_usd,

  -- On-time % so far (based on latest STATUS from FACT_PROGRESS)
  ROUND(
    100 * AVG(IFF(latest_status = 'ON_TRACK', 1, 0)),
    1
  ) AS on_time_pct_so_far,

  -- Budget adherence so far:
  -- 1) overall adherence ratio = actual/budget (to date)
  ROUND(
    100 * (SUM(actual_to_date_usd) / NULLIF(SUM(budget_to_date_usd), 0)),
    1
  ) AS budget_adherence_pct_so_far,

  -- (Optional but useful) % projects within +/-10% of budget to date
  ROUND(
    100 * AVG(
      IFF(
        budget_to_date_usd > 0
        AND ABS(actual_to_date_usd - budget_to_date_usd) / budget_to_date_usd <= 0.10,
        1, 0
      )
    ),
    1
  ) AS pct_projects_within_10pct_budget,

  -- Risk Exposure Index so far (sum across active projects)
  ROUND(SUM(risk_exposure_index), 3) AS risk_exposure_index_so_far

FROM project_kpis;

NOTE: Panel 1 also has a ring chart - number of projects in each program

Panel 2: Schedule Program Health

Table: PMO_DB.FACTS.FACT_PROGRAM_SCHEDULE_HEALTH

Panel 3: Slippage vs Programs

WITH active_projects AS (
  SELECT
    p.PROJECT_ID,
    p.PROJECT_NAME,
    p.PROGRAM_ID,
    p.START_DATE,
    p.END_DATE_PLANNED,
    p.BUDGET_BASELINE_USD
  FROM PMO_DB.DIMENSIONS.DIM_PROJECT p
  WHERE p.IS_ACTIVE = TRUE
),

latest_progress AS (
  SELECT
    fp.PROJECT_ID,
    fp.SNAPSHOT_DATE,
    fp.SPI,
    fp.STATUS
  FROM PMO_DB.FACTS.FACT_PROGRESS fp
  JOIN active_projects ap
    ON ap.PROJECT_ID = fp.PROJECT_ID
  QUALIFY fp.SNAPSHOT_DATE = MAX(fp.SNAPSHOT_DATE) OVER (PARTITION BY fp.PROJECT_ID)
),

project_forecast AS (
  SELECT
    ap.PROGRAM_ID,
    ap.PROJECT_ID,
    ap.PROJECT_NAME,
    ap.BUDGET_BASELINE_USD,
    ap.START_DATE,
    ap.END_DATE_PLANNED,
    lp.SNAPSHOT_DATE,
    lp.SPI,
    lp.STATUS,

    -- planned duration (days)
    GREATEST(1, DATEDIFF('DAY', ap.START_DATE, ap.END_DATE_PLANNED)) AS planned_duration_days,

    -- forecast finish date based on SPI (proxy)
    CASE
      WHEN lp.SPI IS NULL OR lp.SPI <= 0 THEN ap.END_DATE_PLANNED
      ELSE DATEADD(
             'DAY',
             CEIL(DATEDIFF('DAY', ap.START_DATE, ap.END_DATE_PLANNED) / lp.SPI),
             ap.START_DATE
           )
    END AS forecast_finish_date,

    -- slack = planned_end - forecast_finish (positive good, negative late)
    DATEDIFF(
      'DAY',
      CASE
        WHEN lp.SPI IS NULL OR lp.SPI <= 0 THEN ap.END_DATE_PLANNED
        ELSE DATEADD(
               'DAY',
               CEIL(DATEDIFF('DAY', ap.START_DATE, ap.END_DATE_PLANNED) / lp.SPI),
               ap.START_DATE
             )
      END,
      ap.END_DATE_PLANNED
    ) AS slack_days,

    -- delay = forecast - planned (positive late)
    DATEDIFF(
      'DAY',
      ap.END_DATE_PLANNED,
      CASE
        WHEN lp.SPI IS NULL OR lp.SPI <= 0 THEN ap.END_DATE_PLANNED
        ELSE DATEADD(
               'DAY',
               CEIL(DATEDIFF('DAY', ap.START_DATE, ap.END_DATE_PLANNED) / lp.SPI),
               ap.START_DATE
             )
      END
    ) AS projected_delay_days
  FROM active_projects ap
  LEFT JOIN latest_progress lp
    ON lp.PROJECT_ID = ap.PROJECT_ID
),

-- pick the critical-path project per program = worst projected delay (tie-break by biggest budget)
critical_project AS (
  SELECT *
  FROM project_forecast
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY PROGRAM_ID
    ORDER BY projected_delay_days DESC, BUDGET_BASELINE_USD DESC
  ) = 1
),

program_rollup AS (
  SELECT
    pf.PROGRAM_ID,
    COUNT(*) AS active_projects,
    ROUND(AVG(pf.projected_delay_days), 1) AS avg_project_delay_days,
    MAX(pf.projected_delay_days) AS worst_project_delay_days,
    ROUND(100 * AVG(IFF(pf.STATUS = 'ON_TRACK', 1, 0)), 1) AS on_time_project_pct
  FROM project_forecast pf
  GROUP BY 1
)

SELECT
  pr.PROGRAM_ID,
  dp.PROGRAM_NAME,
  pr.active_projects,

  -- critical path proxy (the project most likely to drive program finish)
  cp.PROJECT_ID  AS critical_project_id,
  cp.PROJECT_NAME AS critical_project_name,
  cp.SNAPSHOT_DATE AS critical_snapshot_date,
  cp.SPI AS critical_spi,
  cp.END_DATE_PLANNED AS critical_planned_finish,
  cp.forecast_finish_date AS critical_forecast_finish,
  cp.slack_days AS critical_slack_days,
  cp.projected_delay_days AS critical_projected_delay_days,

  -- program-level rollups
  pr.avg_project_delay_days,
  pr.worst_project_delay_days,
  pr.on_time_project_pct,

  -- status based primarily on critical slack (proxy)
  CASE
    WHEN cp.slack_days >= 7  THEN 'GREEN'
    WHEN cp.slack_days >= -7 THEN 'YELLOW'
    ELSE 'RED'
  END AS status

FROM program_rollup pr
JOIN PMO_DB.DIMENSIONS.DIM_PROGRAM dp
  ON dp.PROGRAM_ID = pr.PROGRAM_ID
JOIN critical_project cp
  ON cp.PROGRAM_ID = pr.PROGRAM_ID
ORDER BY status, cp.slack_days ASC, dp.PROGRAM_NAME;

Panel 4: Portfolio budget vs actual by Month

SELECT
  f.MONTH,
  ROUND(SUM(f.BUDGET_MONTHLY_USD), 2) AS budget_usd,
  ROUND(SUM(f.ACTUAL_SPEND_USD), 2)   AS actual_usd,
  ROUND(SUM(f.ACTUAL_SPEND_USD) - SUM(f.BUDGET_MONTHLY_USD), 2) AS variance_usd,
  ROUND(
    100 * (SUM(f.ACTUAL_SPEND_USD) / NULLIF(SUM(f.BUDGET_MONTHLY_USD), 0)),
    1
  ) AS actual_vs_budget_pct
FROM PMO_DB.FACTS.FACT_FINANCIAL f
JOIN PMO_DB.DIMENSIONS.DIM_PROJECT p
  ON p.PROJECT_ID = f.PROJECT_ID
WHERE p.IS_ACTIVE = TRUE
  AND f.MONTH <= DATE_TRUNC('MONTH', CURRENT_DATE())
GROUP BY 1
ORDER BY 1;

Panel 5: EV/AC/PV

WITH program_month AS (
  -- Reuse the monthly program view from Query #1, but keep only required fields
  WITH active_projects AS (
    SELECT PROJECT_ID, PROGRAM_ID
    FROM PMO_DB.DIMENSIONS.DIM_PROJECT
    WHERE IS_ACTIVE = TRUE
  ),
  progress_proj_month AS (
    SELECT
      ap.PROGRAM_ID,
      fp.PROJECT_ID,
      DATE_TRUNC('MONTH', fp.SNAPSHOT_DATE) AS MONTH,
      fp.SNAPSHOT_DATE,
      fp.EV_USD,
      fp.PV_USD
    FROM PMO_DB.FACTS.FACT_PROGRESS fp
    JOIN active_projects ap
      ON ap.PROJECT_ID = fp.PROJECT_ID
    QUALIFY ROW_NUMBER() OVER (
      PARTITION BY fp.PROJECT_ID, DATE_TRUNC('MONTH', fp.SNAPSHOT_DATE)
      ORDER BY fp.SNAPSHOT_DATE DESC
    ) = 1
  ),
  evpv_program_month AS (
    SELECT
      PROGRAM_ID,
      MONTH,
      SUM(EV_USD) AS EV_USD,
      SUM(PV_USD) AS PV_USD
    FROM progress_proj_month
    GROUP BY 1,2
  ),
  ac_program_month AS (
    SELECT
      p.PROGRAM_ID,
      f.MONTH,
      SUM(f.ACTUAL_SPEND_USD) AS AC_USD
    FROM PMO_DB.FACTS.FACT_FINANCIAL f
    JOIN PMO_DB.DIMENSIONS.DIM_PROJECT p
      ON p.PROJECT_ID = f.PROJECT_ID
    WHERE p.IS_ACTIVE = TRUE
    GROUP BY 1,2
  )
  SELECT
    e.PROGRAM_ID,
    e.MONTH,
    e.PV_USD,
    e.EV_USD,
    COALESCE(a.AC_USD, 0) AS AC_USD
  FROM evpv_program_month e
  LEFT JOIN ac_program_month a
    ON a.PROGRAM_ID = e.PROGRAM_ID
   AND a.MONTH = e.MONTH
  WHERE e.MONTH <= DATE_TRUNC('MONTH', CURRENT_DATE())
),

program_to_date AS (
  SELECT
    PROGRAM_ID,
    ROUND(SUM(PV_USD), 2) AS PV_TD_USD,
    ROUND(SUM(EV_USD), 2) AS EV_TD_USD,
    ROUND(SUM(AC_USD), 2) AS AC_TD_USD,

    ROUND(SUM(EV_USD) - SUM(PV_USD), 2) AS SV_TD_USD,
    ROUND(SUM(EV_USD) - SUM(AC_USD), 2) AS CV_TD_USD,

    ROUND(SUM(EV_USD) / NULLIF(SUM(PV_USD), 0), 3) AS SPI_TD,
    ROUND(SUM(EV_USD) / NULLIF(SUM(AC_USD), 0), 3) AS CPI_TD
  FROM program_month
  GROUP BY 1
)

SELECT
  t.PROGRAM_ID,
  dp.PROGRAM_NAME,
  t.PV_TD_USD,
  t.EV_TD_USD,
  t.AC_TD_USD,
  t.SV_TD_USD,
  t.CV_TD_USD,
  t.SPI_TD,
  t.CPI_TD,

  -- Over/Under (cost) summary
  CASE
    WHEN t.CV_TD_USD >= 0 THEN 'UNDER_OR_ON_COST'
    ELSE 'OVER_COST'
  END AS COST_POSITION,

  -- Simple combined status (edit thresholds to match your PMO)
  CASE
    WHEN t.SPI_TD >= 0.95 AND t.CPI_TD >= 0.95 THEN 'GREEN'
    WHEN t.SPI_TD >= 0.90 AND t.CPI_TD >= 0.90 THEN 'YELLOW'
    ELSE 'RED'
  END AS STATUS

FROM program_to_date t
JOIN PMO_DB.DIMENSIONS.DIM_PROGRAM dp
  ON dp.PROGRAM_ID = t.PROGRAM_ID
ORDER BY
  STATUS,
  t.CV_TD_USD ASC,   -- most over-cost first
  t.SV_TD_USD ASC;   -- most behind schedule next

Panel 6: Util by Team by Qtr

SELECT
  r.TEAM_ID,
  t.TEAM_NAME,
  TO_CHAR(r.MONTH, 'YYYY') || '-Q' || TO_CHAR(r.MONTH, 'Q') AS QUARTER_LABEL,
  DATE_TRUNC('QUARTER', r.MONTH) AS QUARTER_START,

  ROUND(SUM(r.HOURS_ALLOCATED), 2) AS hours_allocated,
  ROUND(SUM(r.HOURS_USED), 2)      AS hours_used,

  ROUND(
    SUM(r.HOURS_USED) / NULLIF(SUM(r.HOURS_ALLOCATED), 0),
    3
  ) AS utilization_ratio,

  ROUND(
    100 * SUM(r.HOURS_USED) / NULLIF(SUM(r.HOURS_ALLOCATED), 0),
    1
  ) AS utilization_pct
FROM PMO_DB.FACTS.FACT_RESOURCE r
JOIN PMO_DB.DIMENSIONS.DIM_TEAM t
  ON t.TEAM_ID = r.TEAM_ID
-- OPTIONAL: limit to last 8 quarters
-- WHERE r.MONTH >= DATEADD('QUARTER', -8, DATE_TRUNC('QUARTER', CURRENT_DATE()))
GROUP BY 1,2,3,4
ORDER BY t.TEAM_NAME, QUARTER_START;

Panel 7: Critical resources / Teams ( For skills - we need add other tables. In rev 2.0 )

WITH next_2q AS (
  SELECT DATE_TRUNC('QUARTER', CURRENT_DATE()) AS q_start,
         DATEADD('QUARTER', 2, DATE_TRUNC('QUARTER', CURRENT_DATE())) AS q_end
),

-- 1?? Capacity pressure by team (future load)
team_load AS (
  SELECT
    r.TEAM_ID,
    SUM(r.HOURS_ALLOCATED) AS hours_allocated,
    SUM(r.HOURS_USED) AS hours_used,
    ROUND(SUM(r.HOURS_USED) / NULLIF(SUM(r.HOURS_ALLOCATED), 0), 3) AS utilization_ratio
  FROM PMO_DB.FACTS.FACT_RESOURCE r, next_2q q
  WHERE r.MONTH >= q.q_start
    AND r.MONTH <  q.q_end
  GROUP BY r.TEAM_ID
),

-- 2?? Latest project SPI to identify schedule risk
latest_progress AS (
  SELECT
    fp.PROJECT_ID,
    fp.SPI
  FROM PMO_DB.FACTS.FACT_PROGRESS fp
  QUALIFY fp.SNAPSHOT_DATE = MAX(fp.SNAPSHOT_DATE) OVER (PARTITION BY fp.PROJECT_ID)
),

-- 3?? Projects at schedule risk
at_risk_projects AS (
  SELECT
    PROJECT_ID,
    SPI
  FROM latest_progress
  WHERE SPI < 0.95
),

-- 4?? Map teams to at-risk projects
team_risk_impact AS (
  SELECT
    fr.TEAM_ID,
    COUNT(DISTINCT fr.PROJECT_ID) AS at_risk_projects_supported,
    ROUND(AVG(ar.SPI), 3) AS avg_spi_supported
  FROM PMO_DB.FACTS.FACT_RESOURCE fr
  JOIN at_risk_projects ar
    ON ar.PROJECT_ID = fr.PROJECT_ID
  GROUP BY fr.TEAM_ID
)

SELECT
  tl.TEAM_ID,
  dt.TEAM_NAME,
  ROUND(100 * tl.utilization_ratio, 1) AS utilization_pct_next_2q,
  COALESCE(tr.at_risk_projects_supported, 0) AS at_risk_projects_supported,
  COALESCE(tr.avg_spi_supported, 1.000) AS avg_spi_of_supported_projects,

  -- Risk Impact Score = overload × project risk volume
  ROUND(
    (tl.utilization_ratio - 1) * COALESCE(tr.at_risk_projects_supported, 0),
    2
  ) AS constraint_risk_score

FROM team_load tl
JOIN PMO_DB.DIMENSIONS.DIM_TEAM dt
  ON dt.TEAM_ID = tl.TEAM_ID
LEFT JOIN team_risk_impact tr
  ON tr.TEAM_ID = tl.TEAM_ID

WHERE tl.utilization_ratio > 1.0
ORDER BY constraint_risk_score DESC NULLS LAST;

Panel 8: Risks vs Probability - Risk bubble chart

WITH open_risks AS (
  SELECT
    p.PROGRAM_ID,
    r.PROJECT_ID,
    r.RISK_ID,
    r.PROBABILITY_PCT,
    r.SEVERITY
  FROM PMO_DB.FACTS.FACT_RISK r
  JOIN PMO_DB.DIMENSIONS.DIM_PROJECT p
    ON p.PROJECT_ID = r.PROJECT_ID
  WHERE r.STATUS = 'OPEN'
),

risk_scored AS (
  SELECT
    PROGRAM_ID,
    PROBABILITY_PCT,
    CASE SEVERITY
      WHEN 'LOW'      THEN 1
      WHEN 'MEDIUM'   THEN 2
      WHEN 'HIGH'     THEN 3
      WHEN 'CRITICAL' THEN 5
      ELSE 1
    END AS impact_weight
  FROM open_risks
)

SELECT
  rs.PROGRAM_ID,
  dp.PROGRAM_NAME,

  ROUND(AVG(rs.PROBABILITY_PCT), 1) AS avg_likelihood_pct,

  ROUND(AVG(rs.impact_weight), 2) AS avg_impact_score,

  COUNT(*) AS open_risk_count,

  -- Risk Exposure Index = likelihood × impact × volume factor
  ROUND(AVG(rs.PROBABILITY_PCT)/100 * AVG(rs.impact_weight) * COUNT(*), 2) AS risk_exposure_index,

  CASE
    WHEN AVG(rs.impact_weight) >= 4 OR AVG(rs.PROBABILITY_PCT) >= 70 THEN 'HIGH'
    WHEN AVG(rs.impact_weight) >= 2.5 OR AVG(rs.PROBABILITY_PCT) >= 50 THEN 'MEDIUM'
    ELSE 'LOW'
  END AS risk_level

FROM risk_scored rs
JOIN PMO_DB.DIMENSIONS.DIM_PROGRAM dp
  ON dp.PROGRAM_ID = rs.PROGRAM_ID
GROUP BY rs.PROGRAM_ID, dp.PROGRAM_NAME
ORDER BY risk_exposure_index DESC;

Panels 9 & 10: To do.


